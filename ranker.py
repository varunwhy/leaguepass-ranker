import pandas as pd
import json
import os
import requests
import re
from datetime import datetime
import pytz
from thefuzz import process

# --- CONSTANTS ---
IST_TZ = pytz.timezone('Asia/Kolkata')
ET_TZ = pytz.timezone('US/Eastern')
DATA_FILE = 'nba_data.json' # The file created by your GitHub Action

# --- 1. LOAD DATA (From JSON) ---
def load_nba_data():
    """
    Loads the data generated by the daily GitHub Action.
    """
    if not os.path.exists(DATA_FILE):
        print("âš ï¸ nba_data.json not found. Waiting for GitHub Action...")
        return None
    try:
        with open(DATA_FILE, 'r') as f:
            data = json.load(f)
            # Verify it has the right keys
            if 'players' in data and 'teams' in data:
                return data
            return None
    except Exception as e: 
        print(f"Error loading JSON: {e}")
        return None

# --- 2. SCHEDULE (CDN - Always Live) ---
def get_schedule_from_cdn(target_date_str):
    url = "https://cdn.nba.com/static/json/staticData/scheduleLeagueV2.json"
    try:
        r = requests.get(url, timeout=5)
        data = r.json()
        dt = datetime.strptime(target_date_str, "%Y-%m-%d")
        target_fmt = dt.strftime("%m/%d/%Y")
        
        games_found = []
        for d in data['leagueSchedule']['gameDates']:
            if target_fmt in d['gameDate']:
                for game in d['games']:
                    games_found.append({
                        'home': game['homeTeam']['teamTricode'],
                        'away': game['awayTeam']['teamTricode'],
                        'time': game.get('gameStatusText', '')
                    })
                break
        return pd.DataFrame(games_found)
    except: return pd.DataFrame()

# --- 3. ODDS ---
try:
    from odds import get_betting_spreads
except:
    def get_betting_spreads(): return {}

# --- HELPER: Timezone ---
def convert_et_to_ist(time_str, game_date_str):
    if not time_str or "Final" in time_str: return time_str
    try:
        match = re.search(r"(\d+):(\d+)\s+(am|pm)", time_str, re.IGNORECASE)
        if not match: return time_str
        h, m, p = match.groups()
        h = int(h) + (12 if p.lower() == 'pm' and int(h) != 12 else 0)
        h = 0 if p.lower() == 'am' and int(h) == 12 else h
        dt_us = datetime.strptime(f"{game_date_str} {h}:{m}", "%Y-%m-%d %H:%M")
        dt_us = ET_TZ.localize(dt_us)
        return dt_us.astimezone(IST_TZ).strftime("%a %I:%M %p")
    except: return time_str

# --- MAIN RANKER ---
def get_schedule_with_stats(target_date_str):
    print(f"ðŸš€ Running Ranker V5.0 (Reader Mode) for {target_date_str}")
    
    games_df = get_schedule_from_cdn(target_date_str)
    if games_df.empty: return pd.DataFrame()

    # Load the Pre-Fetched Data
    db = load_nba_data()
    spreads = get_betting_spreads()
    
    enriched_games = []
    
    for _, row in games_df.iterrows():
        home = row['home']
        away = row['away']
        
        # Defaults
        h_power, a_power = 50, 50
        h_pace, a_pace = 100, 100
        source = "Static Fallback"
        
        # IF JSON EXISTS, USE IT
        if db:
            source = "Live Stats (GitHub)"
            active_set = set(db.get('active_players', []))
            
            # --- HELPER TO CALCULATE TEAM POWER ---
            def get_team_power(team_abbr):
                # 1. Get Roster from JSON
                roster = db['players'].get(team_abbr, [])
                if not roster: 
                    # Fallback to Net Rating if Roster empty
                    net = db['teams'].get(team_abbr, {'net_rating': 0})['net_rating']
                    return 50 + (net * 3)

                fp_sum = 0
                count = 0
                
                # 2. Sum Top 3 Active Players
                for p in roster:
                    name = p['name']
                    # Check Availability
                    is_active = False
                    if name in active_set:
                        is_active = True
                    else:
                        # Fuzzy Check (Handle 'Luka Doncic' vs 'Luka DonÄiÄ‡')
                        match, score = process.extractOne(name, active_set)
                        if score > 90: is_active = True
                    
                    if is_active:
                        fp_sum += p['fp']
                        count += 1
                    
                    if count >= 3: break
                
                # If sum is very low (e.g. < 40), something might be wrong, 
                # but we trust the data.
                return fp_sum

            h_power = get_team_power(home)
            a_power = get_team_power(away)
            
            # --- GET PACE ---
            h_pace = db['teams'].get(home, {'pace': 100})['pace']
            a_pace = db['teams'].get(away, {'pace': 100})['pace']
        
        # --- CALCULATE SCORE ---
        # Normalize Power (Typical superteam sum is ~150-180 FP for top 3)
        match_quality = (h_power + a_power) / 3.5 
        
        avg_pace = (h_pace + a_pace) / 2
        spread = spreads.get(home, 10.0)
        spread_penalty = min(abs(spread) * 2.5, 45)
        pace_bonus = max(0, (avg_pace - 98) * 1.5)
        
        # Base 35
        raw_score = 35 + (match_quality * 0.6) + pace_bonus - spread_penalty
        final_score = max(0, min(100, raw_score))
        
        enriched_games.append({
            'Time_IST': convert_et_to_ist(row['time'], target_date_str),
            'Matchup': f"{away} @ {home}",
            'Spread': spread,
            'Stars': int(match_quality),
            'Score': round(final_score, 1),
            'Pace': round(avg_pace, 1),
            'Win_Pct': 0.5,
            'Source': source
        })
        
    return pd.DataFrame(enriched_games)
